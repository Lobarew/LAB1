# -*- coding: utf-8 -*-
"""основы_python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WlhbGoOzkvqQUnQleUQzCc8AYgXFeBMv

#Задача 1
Написать функцию на вход которой подается строка, состоящая из латинских букв.
Функция должна вернуть количество гласных букв (a, e, i, o, u) в этой строке. Написать тесты для кода
"""

def count_vowels(s):
    count = 0
    vowels = "aeiou"
    for char in s:
        if char.lower() in vowels:
            count += 1
    return count

count_vowels("aueio")

"""# Задача 2
Написать функцию на вход, которой подается строка. Функция должна вернуть true, если
каждый символ в строке встречается только 1 раз, иначе должна вернуть false. Написать тесты для кода
"""

def check_unique_chars(s):
    char_count = {}
    for char in s:
        if char in char_count:
            return False
        char_count[char] = 1
    return True
check_unique_chars("odogidpogi")

"""# Задача 3
Написать функцию, которая принимает положительное число и возвращает количество
бит равных 1 в этом числе. Написать тесты для кода
"""

def count_bits(num):
    count = 0
    while num:
        count += num & 1
        num >>= 1
    return count
count_bits(555111511)

"""# Задача 4
Написать функцию, которая принимает положительное число. Функция должна вернуть то,
сколько раз необходимо перемножать цифры числа или результат перемножения, чтобы
получилось число состоящее из одной цифры.
Например, для входного числа:
· 39 функция должна вернуть 3, так как 3*9=27 => 2*7=14 => 1*4=4
· 4 функция должна вернуть 0, так как число уже состоит из одной цифры
· 999 функция должна вернуть 4, так как 9*9*9=729 => 7*2*9=126 => 1*2*6=12 =>
1*2=2. Написать тесты для кода
"""

def magic(n):
    count = 0
    while n >= 10:
        result = 1
        while n > 0:
            result *= n % 10
            n //= 10
        n = result
        count += 1
    return count
    pass
magic(999)

"""# Задача 5
Написать функцию, которая принимает два целочисленных вектора одинаковой длины и
возвращает среднеквадратическое отклонение двух векторов. Написать тесты для кода
"""

def mse(pred, true):
        return sum((p - t) ** 2 for p, t in zip(pred, true)) / len(pred)

mse([1.3,2],[1,2,4])

"""# Задача 6
Написать функцию, принимающая целое положительное число. Функция должна вернуть
строку вида “(n1**p1)(n2**p2)…(nk**pk)” представляющая разложение числа на простые
множители (если pi == 1, то выводить только ni).
Например, для числа 86240 функция должна вернуть “(2**5)(5)(7**2)(11)”. Написать тесты для кода
"""

def prime_factorization(n):
    factors = []
    i = 2
    while i * i <= n:
        if n % i:
            i += 1
        else:
            n //= i
            factors.append(i)
    if n > 1:
        factors.append(n)

    result = ""
    count = 1
    current = factors[0]

    for i in range(1, len(factors)):
        if factors[i] == current:
            count += 1
        else:
            if count == 1:
                result += f"({current})"
            else:
                result += f"({current}**{count})"
            current = factors[i]
            count = 1

    if count == 1:
        result += f"({current})"
    else:
        result += f"({current}**{count})"

    return result

n = 86240
print(prime_factorization(n))

"""# Задача 7
Написать функцию, принимающая целое число n, задающее количество кубиков. Функция
должна определить, можно ли из данного кол-ва кубиков построить пирамиду, то есть
можно ли представить число n как 1^2+2^2+3^2+…+k^2. Если можно, то функция должна
вернуть k, иначе строку “It is impossible”. Написать тесты для кода
"""

def pyramid(number):
 total = 0
 k = 1
 while sum < n:
    k += 1
    sum += k**2

 if sum == n:
    return k
 else:
    return "It is impossible"

"""# Задача 8
Функция принимает на вход положительное число и определяет является ли оно сбалансированным, т.е. сумма цифр до средних равна сумме цифр после. Средними в случае нечетного числа цифр считать одну цифру, в случае четного - две средних. Написать тесты для кода
"""

def is_balanced_number(num):
    num_str = str(num)
    length = len(num_str)

    if length % 2 == 0:
        mid = length // 2 - 1
    else:
        mid = length // 2

    sum1 = sum(int(digit) for digit in num_str[:mid])
    sum2 = sum(int(digit) for digit in num_str[mid+1:])

    return sum1 == sum2